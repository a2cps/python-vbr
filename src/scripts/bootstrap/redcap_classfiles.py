def choices_to_dict(choices_str: str) -> dict:
    # REDcap choices are expressed as pipe-delimited sets of comma-delim values
    #
    # Used to populate dropdown, checkbox, or slider types
    #
    # Example: 1, Yes | 0, No
    # Example: 0, 0 | .25, 0.25 | .5, 0.5 | 1, 1 | 2, 2 | 4, 4 | 8, 8
    # Example: 1, Unable to obtain blood sample -technical reason | 2, Unable to obtain blood sample -patient related | 3, Sample handling/processing error
    cdict = {}
    for i in choices_str.split('|'):
        i = i.strip()
        ii = i.split(',')
        if len(ii) > 1:
            k = ii[0].strip()
            v = ii[1].strip()
            cdict[k] = v
    return cdict


def choices_are_integer(choices_str: str) -> bool:
    cdict = choices_to_dict(choices_str)
    for k, _ in cdict.items():
        try:
            res = int(k)
        except ValueError:
            return False
    return True


def choices_are_numeric(choices_str: str) -> bool:
    cdict = choices_to_dict(choices_str)
    for k, _ in cdict.items():
        try:
            res = float(k)
        except ValueError:
            return False
    return True


def choices_are_boolean(choices_str: str) -> bool:
    cdict = choices_to_dict(choices_str)
    values = []
    for k, _ in cdict.items():
        try:
            res = int(k)
            values.append(res)
        except ValueError:
            return False
    if len(values) != 2:
        return False
    for v in values:
        if v not in [0, 1]:
            return False
    return True


def choices_are_yesno(choices_str: str) -> bool:
    cdict = choices_to_dict(choices_str)
    values = []
    for k, _ in cdict.items():
        values.append(k)
    if len(values) != 2:
        return False
    for v in values:
        if v not in ['Y', 'N']:
            return False
    return True


def process_data_dict(filename: str, current: dict = None) -> dict:
    """Convert a REDcap Data Dictionary into a minimally processed, actionable Python dict
    """
    # {form_name: { field_name: {}}}
    if current is None:
        ddict = {}
    else:
        ddict = current

    with open(filename, 'r') as csvfile:
        ddreader = csv.reader(csvfile)
        # Strip header
        headers = next(ddreader, None)
        for row in ddreader:
            # Form Name
            form_name = row[1]
            # Variable / Field Name
            var_field_name = row[0]
            # Field Type
            field_type = row[3]
            # Field Label
            field_label = row[4]
            # Choices
            choices = row[5]
            # Identifier
            identifier = row[10]
            if identifier == 'y':
                identifier = True
            else:
                identifier = False

            if form_name != '' and var_field_name != '':
                if field_type in SUPPORTED_FIELD_TYPES:
                    # print('{0}.{1}'.format(form_name, var_field_name))
                    ddict_entry = {
                        'field_type': field_type,
                        'field_label': field_label,
                        'choices': choices,
                        'identifier': identifier,
                        'source': os.path.basename(filename)
                    }
                    if form_name not in ddict:
                        ddict[form_name] = {}
                    ddict[form_name][var_field_name] = ddict_entry

        return ddict


def main(args):
    DEST_DIR = os.path.join(os.path.dirname(redcap.__file__), 'autogenerated')
    TEMPLATES_DIR = os.path.join(os.path.dirname(__file__), 'templates')

    # Ensure class files destination exists
    Path(DEST_DIR).mkdir(parents=True, exist_ok=True)

    ddict = {}
    for dd in redcap_data_dictionaries():
        ddict = process_data_dict(filename=dd, current=ddict)

    init_dict = {}
    for form_name, form_config in ddict.items():

        # Set up class def skeleton
        submodule_name = form_name
        # acute_phase_trajectory_items_v01_6month_daily => RcapAcutePhaseTrajectoryItemsV016MonthDaily
        class_name = 'Rcap' + snake_to_camel_case(form_name)
        # acute_phase_trajectory_items_v01_6month_daily => Acute Phase Trajectory Items V01 6Month Daily
        class_docstring = snake_to_title_string(form_name)
        autogen_string = 'Autogenerated {0} by {1}'.format(
            datetime.today().isoformat(), os.path.basename(__file__))
        keyvals = {
            'redcap_form_name': form_name,
            'class_name': class_name,
            'docstring': class_docstring,
            'module_docstring': autogen_string,
            'parent_class_name': 'RcapTable',
        }

        # Extend class def with column entries
        keyvals['columns'] = {}
        for col_name, col_config in form_config.items():
            if col_config.get('field_type', None) in SUPPORTED_FIELD_TYPES:
                col_type = 'String'

            #####################
            # Translation rules #
            #####################

            # Columns are never nullable (at leasr
            # until we decide what columns CAN be)
            col_nullable = 'False'

            # Empty default comment
            col_comments = []

            # Type shifts
            if col_name == 'guid':
                col_type = 'GUID'
            if col_config.get('field_type', None) == 'yesno':
                col_type = 'Boolean'

            # Process 'Choices' field
            col_choices = col_config.get('choices', '')
            # Try to override type to be more descriptive of field value
            # based on choices available in REDcap form
            if col_choices != '':
                # TODO Implement casting/handling of string, numeric values to 1/0
                if choices_are_boolean(col_choices) or choices_are_yesno(
                        col_choices):
                    col_type = 'Boolean'
                elif choices_are_integer(col_choices):
                    col_type = 'Integer'
                elif choices_are_numeric(col_choices):
                    col_type = 'Numeric'

            # Property source code comments
            col_label = col_config.get('field_label', '')

            # Handle empty field name
            if col_label == '':
                col_label = 'Field Name was empty in Data Dictionary'

            # Ignore multiline field names
            if len(col_label.splitlines()) > 1:
                col_label = 'Ignored multiline Field Name in Data Dictionary'

            # Strip leading numeric
            col_label = re.sub('^[0-9]+\.', '', col_label)

            # Strip leading/trailing whitespace
            col_label = col_label.strip()

            # Strip HTML tags
            if col_label.startswith('<'):
                # col_label = 'Ignored HTML Field Name'
                col_label = re.sub('<[^<]+?>', '', col_label)

            # Strip trailing : character
            if col_label.endswith(':'):
                col_label = re.sub(':$', '', col_label)

            # Truncate label to 64 chars
            if len(col_label) > 64:
                col_label = col_label[:61] + '...'

            # Strip trailing whitespace
            col_label = col_label.rstrip('\n')

            col_comments.append(col_label)
            col_comments.append('Field Type: {0}'.format(
                col_config.get('field_type')))
            if len(col_choices) <= 1:
                col_choices = 'N/A'
            col_comments.append('Choices: {0}'.format(col_choices))

            keyvals['columns'][col_name] = {
                'comments': col_comments,
                'docstring': col_label,
                'nullable': col_nullable,
                'type': col_type
            }

        with open(os.path.join(TEMPLATES_DIR, CLASS_TEMPLATE)) as tf:
            template = Template(tf.read())
        output = template.render(**keyvals)

        with open(os.path.join(DEST_DIR, submodule_name + '.py'), 'w') as cf:
            cf.write(output)
            cf.close()

        # Supports writing 'from <submodule> import <classname> in __init__.py
        init_dict[submodule_name] = class_name

    # Now, write __init__.py with imports
    with open(os.path.join(TEMPLATES_DIR, INIT_TEMPLATE)) as initt:
        template = Template(initt.read())

    # Sort imports before writing
    init_dict = collections.OrderedDict(sorted(init_dict.items()))

    keyvals = {'imports': init_dict, 'module_docstring': autogen_string}
    output = template.render(**keyvals)
    with open(os.path.join(DEST_DIR, '__init__.py'), 'w') as initf:
        initf.write(output)
        initf.close()


if __name__ == '__main__':

    import argparse
    import collections
    import csv
    import re
    import simplejson as json
    import os

    from datetime import datetime
    from jinja2 import Template
    from pathlib import Path
    from vbr.tableclasses import redcap
    from vbr.pgrest.utils import snake_to_camel_case, snake_to_title_string

    from .data import redcap_data_dictionaries

    CLASS_TEMPLATE = 'redcap_tableclass.py.j2'
    INIT_TEMPLATE = 'redcap_tableclasses_init.py.j2'
    SUPPORTED_FIELD_TYPES = ('descriptive', 'text', 'radio', 'dropdown',
                             'checkbox', 'yesno')

    parser = argparse.ArgumentParser()
    parser.add_argument("-H", "--base-url", help="Tapis API url")
    parser.add_argument("-u", "--username", help="Tapis username")
    parser.add_argument("-p", "--password", help="Tapis password")
    args = parser.parse_args()

    main(vars(args))
